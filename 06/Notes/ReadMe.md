# What is Testing 
- Black-box, white-box testing
- Performance Testing, Load Testing, Smoke testing, Integration Testing, Penetration Testing, Unit Testing.
- **Unit Testing** is important component of developer testing which is heavily used in TDD.
  - In.Net/.Net Core supports multiple frameworks for testing 
  - MSTest, **[NUnit](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-nunit)**, xUnit.
- Test-driven development (TDD) is a software development process relying on software requirements being converted to test cases before software is fully developed, and tracking all software development by repeatedly testing the software against all test cases. This is as opposed to software being developed first and test cases created later.
- Mantra: Red, Green, Refactor
- Structure/Phases of Unit Tests: Arrange, Act, Assert
- Process:
    - Start with degenerate test cases first
    - As the tests get more specific the code becomes more generic

## The flow of [TDD](https://www.guru99.com/test-driven-development.html)
1. Create a test case - What you expect the feature is suppose to do
2. Running the test case will fail the first time - obviously since you haven't created the actual implementation details to make it pass
3. Write code so the new test case will pass
4. Make sure old test cases won't fail because of the new feature (probably the biggest thing as to why we do unit testing so anything new added will also test our old functionalities to make sure everything is working as intended)
5. Clean up the code and have proper documentation for other developers

## Unit testing
* Like the word "Unit", you will test a small portion of your code to ensure it is working
* Helpful to check that particular section of your code is working

## Arrange, Act, and Assert (The 3 good ole As)
* Arrange
    * This is where you initialize objects or some values you will need for the test
* Act
    * Invokes the method/function under the test with the arranged objects/values
* Assert
    * Verifies that the action of the method under the tests behaves as expected

## Mocking
* Mocking is quite important whenever you are trying to do some data testing
* Mocking helps devs to ease data testing by using fake data
* Benefits:
    * Ease of use - No need of settinf og the database with complex queries and connection but use fake data generated by library like [Moq]()
    * Isolated - If the data base fails or breakdown your test cases will always pass
## Code Coverage
* It is the percentage given to you on how much lines of your code is actually covered by unit testing
* Ex: Lets say you have a total of 200 lines of code and your unit testins only covers 70 lines of code. That means you have 35% code coverage (Fancy math - 70/200*100 = 35%)
### Generally Supported Code Coverage Formats
- Supported code coverage report format types include all test coverage reports we've seen in the wild so far, including:
    - Most of .xml format types (Cobertura XML, Jacoco XML, etc.)
    - Most of .json format types (Erlang JSON, Elm JSON, etc.)
    - Most of .txt format types (Lcov TXT, Gcov TXT, Golang Txt)
# Unit Testing References
- [NUnit](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-nunit)
- [Must watch code Kata by Uncle bob](https://www.youtube.com/watch?v=kScFczWbwRM)
- [Mocking video](https://learn.microsoft.com/en-us/shows/visual-studio-toolbox/unit-testing-moq-framework)

# [Repository Design Pattern](https://www.codeguru.com/csharp/repository-pattern-c-sharp/)
- The Repository Design Pattern is one of the most popular design patterns to achieve such separation between the actual database, queries and other data access logic from the rest of the application.
- This pattern in C# is used to create an abstraction layer between the data access layer and the business logic layer of the application.That abstraction layer is generally called the Repository Layer and it will directly communicate with the data access layer, gets the data and provides it to the business logic layer.
- In other words, we can say that a Repository Design Pattern acts as a middle layer between the rest of the application and the data access logic
- That means a repository pattern isolates all the data access code from the rest of the application.
- As you can see in our code I have started every data layer with `IRepo` interface and place its separate implementations like for `FileRepo`, then `SqlRepo` and now we can have Repository for Data layer with EFCore.
- Advantages:
    - It centralizes data logic or business logic and service logic.
    - It gives a substitution point for the unit tests.
    - Provides a flexible architecture.
    - If you want to modify the data access logic or business access logic, you don't need to change the repository logic.
    - We can implement the features of DRY(Do not repeat yourself) Principle using the Repository Pattern.
    - One of the most important aspects of this strategy is the separation between the actual database, queries and other data access logic from the rest of the application.So that if we do any changes in any of this logic, then that should affect other logic.

# [Dependency Injection](https://www.c-sharpcorner.com/UploadFile/85ed7a/dependency-injection-in-C-Sharp/)
- Dependency Injection (DI) is a software design pattern. 
- It allows us to develop loosely-coupled code. 
- The intent of Dependency Injection is to make code maintainable as well as testable. 
- Advantages:
    - Reusability of code
    - Ease of refactoring
    - Ease of testing

- those who wonder what is [refactoring](https://refactoring.guru/refactoring)?
    - Refactoring is a systematic process of improving code without creating new functionality that can transform a mess into clean code and simple design

# EF Core
## What is ORM?
- **O**bject **R**elational **M**apper - It helps to map Server side language objects to relational entities of database.
- By Using ORM the developer is at ease as not much of proficiency is required to have appliaction connected with database.
- Using ORM a dev has more control over database and its entities via code.
- The dev do not need to write complex sql queries and remember the complicated syntax either.
- Eg: EntityFramework, EntityFrameworkCore, nHibernate (for java) etc...
- The ORM that we will be using is Entity Framework Core
- ORM is just a wrapper class library over the database middleware like ADO.Net

## Entity Framework Core
* One of the popular ORM for .NET core
* It allows us to work with a database by using .NET objects and almost completely removing the need for most data-access code you usually have to write (unlike our ADO.NET)

## Benefits of using EFCore:
- Compatible with .Net and its versions for Windows, macOS, Linux etc...
- Dev team do not need to be expert in complex SQL operations
- It is easy to use as every this is Object Oriented
- It also encapsulates complex ADO.Net code (as a developer you don't need to be well versed with ADO.Net)
- Since its an encapsulation to ADO.Net it helps to prevent attacks like Sql Injection. Although you can still use queries too for any complex scenario.
- Querying using EF is simply done by using Linq.

## Two approaches to EF
* Database first approach
    * This is when you created a database architecture/schema first
    * It will create the entities and DBcontext for us based on the database
* Code first approach
    * This is when you create a .NET application first
    * It will create the database for you and establish the relationships as well based on the models
    * You would need to create the DBContext

### Setup, installation and configuration (most of the steps are common for code first and Db first)
Install the listed packages in your DL project through .Net CLI or Nuget Package Manager:
- `Microsoft.EntityFrameworkCore.Design` or in VS code: ```dotnet add package Microsoft.EntityFrameworkCore.Design```
    - This should also be installed in your startup project
- `Microsoft.EntityFrameworkCore.Tools` or VSCode : ```dotnet add package Microsoft.EntityFrameworkCore.Tools```
- `Microsoft.EntityFrameworkCore.SqlServer` or in VScode:  ```dotnet add package Npgsql.EntityFrameworkCore.SQLServer```
- `Microsoft.Extensions.Configuration.Json` or in VSCode  ```dotnet add package Microsoft.Extensions.Configuration.Json```
- once you Install the packages run `dotnet ef` command in PMC to verify if Entity Framework is installed. You will see some EF picture with a unicorn as a symbol that EFCore has been installed successfully

### DB First Steps
1. Have the following:
    - Data Layer
    - The necessary packages installed in DL project
2. Run the long scaffold code in the DL project:
    - With Fluent API in Visual Studio PMC - `Scaffold-DbContext "Server=tcp:<server-name>.database.windows.net,1433;Initial Catalog=<Db name>; User ID=<user id>;Password=<password>;" -Provider Microsoft.EntityFrameworkCore.SqlServer -o Entities -Tables table1, table2, table3`
    - With Fluent API in VSCode terminal - `dotnet ef dbcontext scaffold "Server=tcp:<server name>.database.windows.net,1433;Initial Catalog=<db name>;User ID=<userid>;Password=<password>" Microsoft.EntityFrameworkCore.SqlServer --force -o Entities`
      or 
    - Connection String with  Data Annotaions in Visual Studio PMC - `Scaffold-DbContext "Server=tcp:<server-name>.database.windows.net,1433;Initial Catalog=<Db name>; User ID=<user id>;Password=<password>;" -Provider Microsoft.EntityFrameworkCore.SqlServer -DataAnnotations -o Entities -Tables table1, table2, table3`
    - Connection String with Data Annotations in VSCode terminal : `dotnet ef dbcontext scaffold "Server=tcp:<server name>.database.windows.net,1433;Initial Catalog=<db name>;User ID=<user id>;Password=<Password>" Microsoft.EntityFrameworkCore.SqlServer --force --data-annotations -o Entities`
3. Edit the DBContext:
    - Change the name if its weird
    - Edit the onconfiguring method to safely refer to the connection string using appsettings.json
4. Any major change to table structure:
    - If you add a new table, delete a table: go to step 2
    - If you've altered columns in an existing table: edit the necessary entity to reflect those changes

## Useful terminology/artificats to know when working with EF
* DBContext
    * Represents a session with the database
    * So any CRUD operations will start here
    * Also used to configure how EF will construct your database architecture using **Fluent API** in OnModelCreating() method
* Migration - for code - first approach only
    * They are a snapshot of the database architecture given the current state of your models
    * So if you change your models/db architecture, you would need to create another migration and update the database
* Entities
    * It is the model version of the tables of your database
    * So a Student table in Database will have a student entity in EF core
* Relationships
    * Same thing as multiplicity in SQL
    * They way you signify the relationships will be use of data annotations/Fluent API/Model structure
* [Data Annotations](https://www.entityframeworktutorial.net/code-first/dataannotation-in-code-first.aspx)
    * When you use Scaffolding there is an option to add flag `-DataAnnotations` which means you will see entity classes with some attributes/annotations on the top like `[Key]`, `[StringLength]` etc
    * Data Annotations attributes are .NET attributes which can be applied on an entity class or properties to override default conventions in EF.
    * Data annotation attributes are included in the `System.ComponentModel.DataAnnotations` and `System.ComponentModel.DataAnnotations.Schema` 
* **Note**: Data annotations only give you a subset of configuration options. Fluent API provides a full set of configuration options available in Code-First. This is why Microsoft suggests to use **[Fluent API](https://www.entityframeworktutorial.net/code-first/fluent-api-in-code-first.aspx)** instead of Data Annotations.

Other things you'll need with DBFirst:
- A Mapper to map your DB entities to BL entities
- [Tutorial guide](https://www.entityframeworktutorial.net/what-is-entityframework.aspx)
- [Exercises](https://learn.microsoft.com/en-us/training/modules/persist-data-ef-core/)